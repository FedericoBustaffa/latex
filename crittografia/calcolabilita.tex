\chapter{Teoria della calcolabilit\`a}\label{calcolabilita}
La \textbf{calcolabilit\`a} si occupa delle questioni fondamentali circa la potenza e le limitazioni dei sistemi di
calcolo e cerca di definire le nozioni di \textbf{algoritmo} e di \textbf{problema non decidibile}.

In altre parole si occupa di classificare i problemi in \emph{risolvibili} e \emph{non risolvibili} per via algoritmica.


\section{Insiemi numerabili}\label{insiemi_numerabili}
\begin{itemize}
	\item Due insiemi $A$ e $B$ hanno lo stesso numero di elementi se e solo se \`e possibile stabilire una
	      \textbf{corrispondenza biunivoca} tra i loro elementi.
	\item Un insieme \`e \textbf{numerabile} se e solo se i suoi elementi possono essere messi in
	      \textbf{corrispondenza biunivoca con i numeri naturali}.
\end{itemize}

\subsection{Enumerazione delle sequenze}
Se volessimo elencare, in un ordine ragionevole, le sequenze di lunghezza finita costruite su un alfabeto finito ci
scontreremmo con un problema: le sequenze non sono in numero finito rendendo impossibile completare l'elenco.

Lo scopo, in questo caso, \`e raggiungere qualsiasi sequenza $\sigma$, arbitrariamente scelta, in un numero finito di
passi. Per farlo, $\sigma$ deve trovarsi a distanza \emph{finita} dall'inizio dell'elenco.

\subsubsection{Ordinamento canonico}
Per riuscire ad enumerare queste sequenze dobbiamo ricorrere al cosiddetto \textbf{ordinamento canonico}:
\begin{enumerate}
	\item Si ordinano le sequenze in ordine di lunghezza crescente.
	\item A parit\`a di lunghezza si ordinano le sequenze secondo l'ordinamento tra i caratteri dell'alfabeto.
\end{enumerate}
Una sequenza $s$ arbitraria si trover\`a quindi tra quelle di $| s |$ caratteri, in una posizione corrispondente
all'ordine alfabetico relativo all'alfabeto $\Gamma$ che stiamo utilizzando.

\begin{example}
	Consideriamo l'alfabeto composto da sole lettere
	\[ \Gamma = \{ a, b, c, \dots, z \} \]
	e scriviamo le sequenze nell'ordine canonico
	\begin{gather*}
		a, \quad b, \quad c, \quad \dots, \quad z, \quad aa, \quad ab, \quad \dots, \quad az, \\
		ba, \quad \dots, \quad bz, \quad za, \quad \dots, \quad zz, \quad aaa, \quad \dots, \quad zzz, \quad \dots
	\end{gather*}
	Come possiamo vedere, si pu\`o costruire un numero infinito di sequenze ma tutte di lunghezza finita e, soprattutto,
	che si possono mettere in corrispondenza biunivoca con l'insieme dei numeri naturali.
\end{example}

\begin{observation}
	L'enumerazione delle sequenze \`e possibile perch\'e esse sono di lunghezza finita anche se illimitata. Quindi,
	scelto un intero $d$, esistono sempre sequenze di lunghezza maggiore di $d$. Se le sequenze fossero di lunghezza
	infinita l'insieme non sarebbe numerabile.
\end{observation}


\subsection{Problemi computazionali}
Un problema computazionale pu\`o essere visto come una \emph{funzione matematica} che associa ad ogni insieme di dati,
espressi da $k$ numeri interi, il corrispondente risultato, espresso da $q$ numeri interi.
\[ f : N^k \rightarrow N^q \]
L'insieme delle funzioni $f : N^k \rightarrow N^q$ non \`e numerabile.

\begin{theorem}\label{th: non_num}
	L'insieme dei problemi computazionali \textbf{non \`e numerabile}.
\end{theorem}

\subsubsection{Diagonalizzazione}
Per dimostrare il teorema \ref{th: non_num} si pu\`o usare il procedimento di \textbf{diagonalizzazione}.
\begin{theorem}
	L'insieme di funzioni
	\[ F = \{ f \mid f : N \rightarrow \{0, 1\} \} \]
	nel quale ogni $f \in F$ pu\`o essere rappresentata da una sequenza infinita del tipo
	\[
		\begin{matrix}
			x    &  & 0 & 1 & 2 & \dots & n & \dots \\
			f(x) &  & 0 & 1 & 0 & \dots & 0 & \dots
		\end{matrix}
	\]
	o, se possibile, da una regola finita di costruzione
	\[
		f(x) = \begin{cases}
			0 & \text{se } x \text{ \`e pari}    \\
			1 & \text{se } x \text{ \`e dispari}
		\end{cases}
	\]
	\textbf{non \`e numerabile}.

	\begin{proof}
		Dimostriamo il teorema per assurdo, ammettiamo quindi che $F$ sia numerabile.

		Dato che $F$ \`e numerabile allora possiamo assegnare, ad ogni funzione $f \in F$, un numero progressivo nella
		numerazione, e costruire una tabella (infinita) di tutte le funzioni.
		\begin{center}
			\begin{tabular}{c | c c c c c}
				$x$      & 0     & 1     & 2     & 3     & \dots \\
				\hline
				$f_0(x)$ & 1     & 0     & 1     & 0     & \dots \\
				$f_1(x)$ & 0     & 0     & 1     & 1     & \dots \\
				$f_2(x)$ & 1     & 1     & 0     & 1     & \dots \\
				$f_3(x)$ & 0     & 1     & 1     & 0     & \dots \\
				\dots    & \dots & \dots & \dots & \dots & \dots
			\end{tabular}
		\end{center}
		Consideriamo adesso la funzione $g \in F$
		\[
			g(x) = \begin{cases}
				0 & f_x (x) = 1 \\
				1 & f_x (x) = 0
			\end{cases}
		\]
		La funzione $g$, cos\`i definita, \textbf{non} corrisponde a nessuna delle $f_i$ in tabella. Questo perch\'e
		differisce sicuramente nei valori posti sulla diagonale principale.
		\begin{center}
			\begin{tabular}{c | c c c c c}
				$x$      & 0     & 1     & 2     & 3     & \dots \\
				\hline
				$f_0(x)$ & 1     & 0     & 1     & 0     & \dots \\
				$f_1(x)$ & 0     & 0     & 1     & 1     & \dots \\
				$f_2(x)$ & 1     & 1     & 0     & 1     & \dots \\
				$f_3(x)$ & 0     & 1     & 1     & 0     & \dots \\
				\dots    & \dots & \dots & \dots & \dots & \dots \\
				\hline
				$g(x)$   & 0     & 1     & 1     & 1     & \dots
			\end{tabular}
		\end{center}
		Ecco che si giunge ad una contraddizione.
	\end{proof}
\end{theorem}

\subsection{Il problema della rappresentazione}
L'informatica rappresenta tutte le sue entit\`a (quindi anche gli algoritmi) in forma digitale, come
\textbf{sequenze finite di simboli di alfabeti finiti}.

Lo stesso vale per gli \textbf{algoritmi}, i quali sono composti da una sequenza finita di operazioni,
\textbf{completamente} e \textbf{univocamente} determinate. Gli algoritmi, quindi, sono potenzialmente infiniti ma
comunque \textbf{numerabili}.

Come gi\`a detto, i problemi computazionali non sono numerabili e dunque abbiamo molti pi\`u problemi che algoritmi.
Questo implica necessariamente che esistano problemi \textbf{privi} di un algoritmo di calcolo per la loro risoluzione.

\section{Il problema dell'arresto}\label{arresto}
Formulato da Alan Turing, consiste in un algoritmo che indaga le proprit\`a di un altro algoritmo, trattato come dato
in input.

\begin{center}
	Presi arbitrariamente un algoritmo $A$ e i suoi dati di input $D$, decidere in \textbf{tempo finito} se la computazione
	di $A$ su $D$ termina o no.
\end{center}
Sebbene il problema sia ben formulato e lecito, dato che un algoritmo e i relativi dati in ingresso sono codificati con
lo stesso alfabeto, Turing stesso ha dimostrato che \`e \textbf{impossibile} riuscire a stabilire (in tempo finito) se
un programma arbitrario si arresta e termina la sua esecuzione.

\begin{theorem}
	Il problema dell'arresto \`e \textbf{indecidibile}.

	\begin{proof}
		Per dimostrarlo dobbiamo considerare un generico algoritmo \verb|A|, con un generico input \verb|D|.
		L'algoritmo \verb|ARRESTO| prende in input \verb|A| e \verb|D| e ritorna
		\begin{itemize}
			\item \verb|true| se \verb|A(D)| termina.
			\item \verb|false| altrimenti.
		\end{itemize}
		Se \verb|A(D)| termina, \verb|ARRESTO| ritorna \verb|true| e non ci sono problemi. Se invece non termina,
		\verb|ARRESTO| non \`e in grado di rispondere \verb|false| in tempo finito.

		Questo perch\'e \verb|ARRESTO| non pu\`o non passare dalla simulazione di \verb|A| su \verb|D| e quindi, nel
		caso \verb|A| non termini, \verb|ARRESTO| non terminerebbe a sua volta.

		Se esistesse l'algoritmo \verb|ARRESTO|, esisterebbe anche il seguente algoritmo
		\begin{lstlisting}[style=pseudo-style]
PARADOSSO(A)
	while (ARRESTO(A, A));
		\end{lstlisting}
		\begin{center}
			\verb|PARADOSSO| termina
			\[ \Leftrightarrow \]
			\verb|ARRESTO(A, A) = false|
			\[ \Leftrightarrow \]
			\verb|ARRESTO| non termina.
		\end{center}

		Se provassimo a calcolare \verb|PARADOSSO(PARADOSSO)|
		\begin{center}
			\verb|PARADOSSO(PARADOSSO)| termina
			\[ \Leftrightarrow \]
			\verb|ARRESTO(PARADOSSO, PARADOSSO) = false|
			\[ \Leftrightarrow \]
			\verb|PARADOSSO(PARADOSSO)| non termina
		\end{center}
		Ma ecco che si giunge ad una contraddizione.
	\end{proof}
\end{theorem}
