\part{Complessità}

\chapter{Introduzione alla complessità}

In questo capitolo andiamo ad introdurre la teoria della
\textbf{complessità}, in particolare limitandoci ai problemi
decidibili. La complessità che prendiamo noi in esame studia
quindi problemi ricorsivi limitando le risorse per il calcolo,
in particolare parleremo di limitazioni in tempo e spazio.

Tratteremo quindi problemi più \emph{concreti} formalizzandoli
nella loro forma decisionale e andando quindi a studiare di
quante risorse un certo problema ha bisogno per essere deciso.

Quando ad esempio ci troviamo davanti ad un'instanza $x$ del
problema vogliamo determinare se $x \in I$ dove $I$ è la classe
di complessità di quel problema. Per farlo dobbiamo quindi
cercare una funzione $f$ calcolabile totale che riesca a stimare
il tempo (o lo spazio) necessario alla decisione.

Non siamo però interessati ad una funzione che determini
precisamente il quantitativo di risorse necessarie alla
decisione, bensì una funzione che maggiori il tempo (o lo spazio)
necessario al calcolo. In particolare cerchiamo $f$ tale che
\[ f(|x|) \geq \text{tempo o spazio} \]
dove $|x|$ indica la \textbf{taglia} del problema ovvero, detto
in termini più semplici, la dimensione dell'input, o detto in
termini di macchine di Turing, di quante "caselle" abbiamo
bisogno per rappresentare l'input sul nastro.

Ovviamente per avere una stima più accurata possibile vogliamo
la minima $f$ che maggiora il tempo per una certa classe di
problemi. Vogliamo inoltre che tale funzione sia monotona
crescente, di modo da studiare la complessità
\textbf{asintotica}, dato che siamo interessati a vedere come
cresce l'uso delle risorse al crescere della dimensione
dell'input. Questo significa che tale funzione, da un certo
punto in poi deve essere sempre maggiore del tempo necessario
alla decisione di un certo problema per la classe di problemi
considerata. Altra considerazione da fare è che a noi interessa
solo lo studio del caso pessimo, in quanto è il più rilevante e
caratterizza meglio la classe di complessità considerata.

Una volta trovata tale $f$, diciamo che questa \textbf{determina}
la classe di complessità. Andiamo quindi a definire meglio una
classe di complessità

\begin{definition}
	Una \textbf{classe di complessità} è l'insieme dei problemi
	per cui una certa $f$ maggiora tempo o spazio.
\end{definition}

In una classe di complessità ci saranno quindi tutti quei
problemi che richiedono almeno quella misura di complessità, che
sia in tempo o spazio. Prendiamo ad esempio una funzione $g$
tale che
\[ g > f \]
allora se il problema sta in una classe di complessità
determinata da $f$, sta anche nella classe di complessità
determinata da $g$. Questo è banale poiché se $g$ rappresenta un
limite maggiore alle risorse, se la l'algoritmo funziona bene
con $f$ risorse a disposizione, dandogli più risorse funzionerà
ancora se non meglio.

Da notare che la funzione $f$ deve maggiorare il tempo di
calcolo per tutti gli algoritmi che sono in grado di risolvere
il problema di decidere se $x \in I$. Questo perché a noi
interessa il caso pessimo e anche perché, come vedremo, un
algoritmo può essere trasformato, tramite riduzioni, ad altri
algoritmi equivalenti.

Siamo ovviamente anche interessati a trovare problemi completi
per una classe di complessità, in modo da caratterizzare tale
classe. Trovare uno di questi problemi pone un limite alla
difficoltà dei problemi di tale classe. Questo, insieme allo
studio delle funzioni di stima ci aiuta anche nella definizione
di una gerarchia tra le classi.
