\section{Codifiche}
Ci chiediamo ora se per una funzione $f$ che non opera su
dati sotto formato di stringa, memorie o numeri naturali,
le nozioni di calcolabilità che abbiamo definito fino ad ora
sono ancora valide.

Se così non fosse dovremmo ridefinire ogni volta tali nozioni
per ogni dominio di ogni funzione con un formato differente da
quelli che abbiamo già incontrato.

Per superare il problema si fa uso di opportune
\textbf{codifiche} dei dati, ossia funzioni che svolgono
il seguente compito.
\begin{enumerate}
	\item Dato $x$ in formato $A$, lo si codifica in un formato
	      $B$ che ci permette di effettuare il calcolo con un
	      formalismo che conosciamo, per esempio le MdT e
	      otteniamo $y$.
	\item Si applica la MdT a $y$ e si ottiene il risultato $z$
	      (se la computazione termina) in formato $B$.
	\item Si traduce $z$ dal formato $B$ al formato $A$.
\end{enumerate}
D'ora in avanti considereremo solo i numeri naturali come i
nostri dati. Abbiamo però bisogno che la funzione di codifica
sia \emph{biunivoca}.

\begin{example}
	La seguente funzione codifica coppie di naturali come un
	singolo naturale ed è detta codifica a
	\textbf{coda di colomba}.
	\[ (x, y) \to \frac{1}{2} (x^2 + 2 x y + y^2 + 3 x + y) \]
	la cui decodifica, ossia la funzione inversa è la seguente
	\[
		n \to (n - \frac{1}{2} k \cdot (k + 1),
		k - (n - \frac{1}{2} k \cdot (k + 1))
	\]
	dove $k=\lfloor \frac{1}{2}(\sqrt{1+8\cdot n}-1)\rfloor$.
\end{example}

Possiamo quindi dire che le proprietà basilari dei formalismi
e delle classi di funzioni calcolate, non cambiano al variare
del formato dei dati su cui operano.

\begin{definition} \label{def: funzione totale}
	Diciamo che una funzione $f : A \to B$, sottoinsieme di
	$A \times B$ è una \textbf{funzione totale} se e solo se
	\begin{itemize}
		\item \`E \emph{definita ovunque}, ossia se
		      $\forall a \in A$, $\exists b \in B$ tale che la
		      coppia $(a, b) \in f$.
		\item Vi è \emph{unicità}, ossia se, date le coppie
		      $(a, b) \in f$ e $(a, c) \in f$, allora $b=c$.
	\end{itemize}
	Una funzione totale è quindi suriettiva ma potrebbe non
	essere iniettiva.
\end{definition}

Una funzione può essere calcolabile ma non totale, per esempio
la macchina di Turing che non termina mai vista nell'esempio
\ref{ex: non termina}.

\begin{definition} \label{def: funzione parziale}
	Diciamo che una funzione $f : A \to B$ è \textbf{parziale}
	se è un sottoinsieme di $A \times B$ tale che
	\begin{itemize}
		\item Vi è \emph{unicità}, ossia se, date le coppie
		      $(a, b) \in f$ e $(a, c) \in f$, allora $b = c$.
		\item Esiste al più un $b \in B$ tale che $f(a) = b$.
	\end{itemize}
	e quindi non si richiede che $f$ sia definita ovunque.
\end{definition}

Introduciamo ora un po' di notazione utile a quello che faremo
più avanti. Data una funzione $f : A \to B$
\begin{itemize}
	\item Diremo che $f$ è \textbf{definita} o
	      \textbf{converge su $a$} ($f(a) \downarrow$) se
	      $\exists b$ tale che $(a, b) \in f$ (cioè
	      $f(a) = b$).
	\item Diremo che $f$ \textbf{non è definita} o che
	      \textbf{diverge} ($f(a) \uparrow$) se $\nexists b$
	      tale che $(a, b) \in f$.
\end{itemize}
Chiamiamo inoltre
\begin{itemize}
	\item \textbf{Dominio} di $f$ l'insieme
	      \[ \{ a \in A \; | \; f(a) \downarrow \} \]
	      che coincide con lo spazio di partenza ($A$) se e
	      solo se la funzione è totale.
	\item \textbf{Codominio} di $f$ l'insieme $B$.
	\item \textbf{Immagine} di $f$ l'insieme
	      \[ \{ b \in B \; | \; \exists a \in A : f(a) = b \} \]
	      Quando immagine e codominio coincidono abbiamo una
	      funzione suriettiva.
\end{itemize}

Detto questo vogliamo capire qual è la relazione tra funzioni
e algoritmi. Una funzione possiamo vederla come un insieme di
coppie (\emph{argomento}, \emph{risultato}) (o (\emph{input},
\emph{output}) se preferiamo la notazione più informatica) ma
non ci dice come il risultato (o l'output) venga calcolato.

Di conseguenza non ci sono due funzioni diverse che per uno
stesso argomento restituiscono lo stesso risultato. In termini
insiemistici possiamo dire che non esistono due insiemi diversi
che hanno gli stessi elementi.
\begin{tcolorbox}
	Un algoritmo è invece una \textbf{rappresentazione finita}
	di una funzione, in quanto specifica come si calcola il
	risultato a partire dall'argomento. In questo caso possiamo
	certamente avere più algoritmi che calcolano la stessa
	funzione.
\end{tcolorbox}
Per esempio possiamo scrivere infiniti programmi \verb|WHILE|
che calcolano la stessa funzione aggiungendo dei comandi
\verb|skip| ad ognuno di essi.