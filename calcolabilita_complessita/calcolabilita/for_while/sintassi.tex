\chapter{Linguaggi FOR e WHILE}
Introduciamo ora un formalismo sicuramente a noi più familiare,
che è quello di un semplice linguaggio \textbf{imperativo} e
che quindi riesce ad esprimere i concetti di \textbf{memoria}
e di \textbf{comando}.

\section{Sintassi astratta}
La sintassi proposta è \emph{ambigua}, abbiamo dunque diverse
possibili interpretazioni per la stessa stringa. In realtà
tale sintassi viene elaborata tramite alberi, che hanno proprio
il compito di eliminare eventuali ambiguità.

Come vedremo a breve si tratta di una sintassi molto semplice,
comprendente costrutti condizionali di base, la possibilità
di eseguire cicli e semplici operazioni aritmetiche e logiche.

\begin{align*}
	E \to                                                 &
	\; n \; | \; x \; | \; E_1 + E_2 \; | \;
	E_1 \times E_2 \; | \; E_1 - E_2
	                                                      &
	\text{Espressioni aritmetiche}                          \\
	B \to                                                 &
	\; b \; | \; E_1 < E_2 \; | \; \lnot B \; | \;
	B_1 \lor B_2
	                                                      &
	\text{Espressioni booleane}                             \\
	C\to                                                  &
	\; \text{skip} \; | \; x := E \; | \; C_1 ; C_2 \; | \;
	\text{if } B \text{ then } C_1 \text{ else } C_2 \; | &
	\text{Comandi}                                          \\ &
	\; \text{for } x = E_1 \text{ to } E_2 \text{ do } C \; |
	\; \text{while } B \text{ do } C
\end{align*}

dove $n \in \N$, $x \in \Var$ (insieme numerabile di
variabili) e $b \in \text{Bool} = \{ tt, ff \}$.

D'ora in poi chiameremo \verb|WHILE|, il linguaggio descritto
dalla grammatica BNF di sopra. Chiameremo invece \verb|FOR|,
il linguaggio risultante dall'omissione del comando \verb|while|
della stessa grammatica.

