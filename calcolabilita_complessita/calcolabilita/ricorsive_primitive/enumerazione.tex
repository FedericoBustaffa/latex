\section{Enumerazione Macchine di Turing}
\label{ssec: enum MdT}
Quel che vogliamo fare adesso è utilizzare quanto appena detto
per costruire una codifica delle macchine di Turing e delle
loro computazioni. Prendiamo una MdT
\[ M = (Q, \Sigma, \delta, q_0) \]
con
\[
	Q = \{ q_0, \dots, q_n \} \text { e }
	\Sigma = \{ \sigma_0, \dots, \sigma_m \}
\]
Possiamo codificare ogni quintupla
$(q_i, \sigma_j, q_k, \sigma_t, D) \in \delta$ come
\[
	p_0^{i+1} \cdot p_1^{j+1} \cdot
	p_2^{k+1} \cdot p_3^{t+1} \cdot p_4^{m_D}
\]
dove $p_0 < \dots < p_4$ sono numeri primi. Ordiniamo in qualche
modo l'insieme dei suoi stati e l'insieme dei suoi simboli e
vedremo che tale ordinamento si riflette anche sulle quintuple
della funzione di transizione.

Dato che la quintupla altro non è che una successione di cinque
simboli, allora possiamo codificarla tramite il teorema di unica
fattorizzazione. Se codifichiamo tutte le possibili quintuple di
una MdT otteniamo una nuova sequenza, anch'essa codificabile.

Codificando quest'ultima sequenza otteniamo un numero $i$,
detto anche \textbf{indice}, che identifica $M$. Siamo quindi
riusciti a codificare una MdT come un numero. Nulla ci vieta
di quindi di codificare ogni MdT come un numero.

La funzione proposta non è suriettiva ma solo iniettiva: non
sempre è infatti possibile, da un indice, ricavare una MdT
ma questo non è un problema in quanto possiamo tranquillamente
considerare l'indice non valido.

In realtà un modo per avere una funzione biunivoca c'è e va
sotto il nome di \textbf{g\"odelizzazione} la quale ci permette
di enumerare le funzioni ma anche le computazioni.

Per convincersi di questo è possibile notare che ora come ora
siamo in grado di enumerare le MdT basandoci unicamente sui
simboli usati per definirle. Ovviamente lo stesso procedimento
è applicabile alle possibili configurazioni di una MdT e dunque
alle computazioni (che altro non sono che una sequenza di
configurazioni).
